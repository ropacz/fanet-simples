# =============================================================================
# FANET (Flying Ad-hoc Network) Simulation Configuration
# 
# Simulação de rede ad-hoc de veículos aéreos não tripulados (UAVs)
# com Estação de Controle Terrestre (GCS)
#
# Versão: OMNeT++ 6.2.0 + INET Framework 4.5.4
# Status: Comunicação wireless funcional (corrigido broadcast + limitedBroadcast)
# =============================================================================

[General]
network = FANET
sim-time-limit = 300s  # 5 minutos de simulação
seed-set = ${runnumber}

# === CONFIGURAÇÕES DE LOG ===
# Configurações globais do cmdenv
cmdenv-express-mode = true
cmdenv-autoflush = true
cmdenv-log-prefix = "[%l] %C: "

# Reduzir verbosidade dos logs do sistema
**.scalar-recording = false
**.vector-recording = false

# Filtros de log para mostrar apenas informações relevantes  
**.**.logLevel = "WARN"    # Apenas warnings e erros por padrão
**.app[0].logLevel = "INFO"   # Manter logs da aplicação FANET

# === CONFIGURAÇÃO DA REDE ===
**.numUAVs = 5  # 5 UAVs + 1 GCS

# === MOBILIDADE ===
# UAVs com mobilidade arbitrária (reduzida para manter posições estratégicas)
**.uav[*].mobility.typename = "ArbitraryMobility"
**.uav[*].mobility.minSpeed = 5mps    # Velocidade reduzida para manter topologia
**.uav[*].mobility.maxSpeed = 10mps   # Velocidade reduzida para manter topologia
**.uav[*].mobility.minAltitude = 80m
**.uav[*].mobility.maxAltitude = 120m
**.uav[*].mobility.constraintAreaMinX = 200m
**.uav[*].mobility.constraintAreaMinY = 200m
**.uav[*].mobility.constraintAreaMaxX = 1800m
**.uav[*].mobility.constraintAreaMaxY = 1800m
**.uav[*].mobility.updateInterval = 1s  # Movimento mais lento

# Posições iniciais calculadas para demonstrar relay natural
# GCS no centro (1000, 1000) com alcance de 500m
# Distâncias calculadas para garantir conectividade em cadeia

# Posições iniciais estratégicas para forçar relay multi-hop
# GCS no centro (1000, 1000) com alcance de 300m
# UAVs com alcance de 200m
# Topologia em cadeia: UAV[0,1,2] → GCS | UAV[3] → UAV[1] → GCS | UAV[4] → UAV[3] → UAV[1] → GCS

# UAVs 0-2: Dentro do alcance direto do GCS (< 300m)
**.uav[0].mobility.initialX = 850m   # Distância do GCS: ~212m
**.uav[0].mobility.initialY = 850m
**.uav[0].mobility.initialZ = 100m

**.uav[1].mobility.initialX = 1100m  # Distância do GCS: ~141m (ponte para relay)
**.uav[1].mobility.initialY = 1100m
**.uav[1].mobility.initialZ = 100m

**.uav[2].mobility.initialX = 800m   # Distância do GCS: ~200m
**.uav[2].mobility.initialY = 1000m
**.uav[2].mobility.initialZ = 100m

# UAV[3]: Primeiro relay - fora do GCS mas conectado ao UAV[1] 
**.uav[3].mobility.initialX = 1240m  # Distância do GCS: ~339m (fora de 300m)
**.uav[3].mobility.initialY = 1240m  # Distância do UAV[1]: ~198m (dentro de 200m) ✓
**.uav[3].mobility.initialZ = 100m

# UAV[4]: Segundo relay - conectado apenas ao UAV[3]
**.uav[4].mobility.initialX = 1380m  # Distância do GCS: ~537m (muito fora)
**.uav[4].mobility.initialY = 1380m  # Distância do UAV[3]: ~198m (dentro de 200m) ✓
**.uav[4].mobility.initialZ = 100m

# GCS estacionária no centro
**.gcs.mobility.typename = "StationaryMobility"
**.gcs.mobility.initialX = 1000m
**.gcs.mobility.initialY = 1000m
**.gcs.mobility.initialZ = 10m

# === APLICAÇÃO FANET ===
**.app[0].typename = "FANETApp"
**.app[0].localPort = 1000
**.app[0].destPort = 1000
**.app[0].neighborTimeout = 30s
**.app[0].startTime = 1s

# Configurações específicas por tipo de nó
**.uav[*].app[0].isGCS = false
**.uav[*].app[0].maxTransmissionRange = 200m  # Mais conservador que a física (250m)

**.gcs.app[0].isGCS = true
**.gcs.app[0].maxTransmissionRange = 300m  # Mais conservador que a física (400m)

# === INTERFACES WIRELESS ===
# Configuração explícita para AdhocHost - garantir operação correta

# Configurações MAC para broadcast otimizado
**.wlan[*].mac.dcf.channelAccess.pendingQueue.typename = "DropTailQueue"
**.wlan[*].mac.dcf.channelAccess.pendingQueue.frameCapacity = 10

# Configurações explícitas para modo ad-hoc
**.wlan[*].mgmt.ssid = "FANET"
**.wlan[*].mgmt.typename = "Ieee80211MgmtAdhoc"
**.wlan[*].mac.address = "auto"

# FORÇAR interface ATIVA desde o início
**.wlan[*].radio.radioMedium = "radioMedium"  # Conectar ao meio físico
**.interfaceTable.displayAddresses = true

# Forçar resolução ARP automática para broadcasts
**.arp.typename = "GlobalArp"  # Resolver endereços automaticamente

# === POTÊNCIA DE TRANSMISSÃO ===
# Configurações muito restritivas para forçar alcances corretos
**.uav[*].wlan[*].radio.transmitter.power = 15mW     # ~250m alcance máximo
**.gcs.wlan[*].radio.transmitter.power = 80mW       # ~400m alcance máximo
**.wlan[*].radio.centerFrequency = 2.4GHz

# Configurações de antena
**.wlan[*].radio.antenna.typename = "IsotropicAntenna"

# === MEIO FÍSICO ===
**.radioMedium.typename = "Ieee80211ScalarRadioMedium"
**.radioMedium.mediumLimitCache.carrierFrequency = 2.4GHz
**.radioMedium.backgroundNoise.power = -110dBm  # Ruído de fundo baixo e realístico

# Configurações específicas do radioMedium para INET 4.5.4
**.radioMedium.pathLoss.typename = "FreeSpacePathLoss"
**.radioMedium.pathLoss.alpha = 2.0  # Expoente de perda de caminho
**.radioMedium.pathLoss.systemLoss = 0dB  # Sem perdas adicionais do sistema
**.radioMedium.obstacleLoss.typename = ""
**.radioMedium.analogModel.typename = "ScalarAnalogModel"

# Adicionando filtro de proximidade mais rigoroso
**.radioMedium.neighborCache.maxCommunicationRange = 300m  # Mais restritivo
**.radioMedium.communicationCache.maxCommunicationRange = 300m

# Forçar limite de comunicação baseado na distância - muito restritivo
**.radioMedium.rangeFilter.maxCommunicationRange = 300m  # Limite absoluto baixo
**.radioMedium.rangeFilter.maxInterferenceRange = 350m

# Configurações de recepção balanceadas - permitir comunicação mas com controle na aplicação
**.uav[*].wlan[*].radio.receiver.energyDetection = -95dBm  # Detectar sinais fracos
**.uav[*].wlan[*].radio.receiver.sensitivity = -95dBm      # Receber sinais adequados
**.gcs.wlan[*].radio.receiver.energyDetection = -100dBm    # GCS mais sensível   
**.gcs.wlan[*].radio.receiver.sensitivity = -100dBm        # GCS pode receber sinais mais fracos

# === CONFIGURAÇÃO IP ===
# Configuração automática de endereços IP para AdhocHost no INET 4.5.4
**.configurator.config = xml("<config><interface hosts='**' address='192.168.1.x' netmask='255.255.255.0'/></config>")

# Configurações críticas para AdhocHost funcionar corretamente
**.configurator.addDefaultRoutes = false  # Não adicionar rotas padrão automáticas
**.configurator.addStaticRoutes = true    # Adicionar rotas estáticas para broadcast
**.configurator.addSubnetRoutes = true    # Adicionar rotas de subnet
**.configurator.optimizeRoutes = false    # Não otimizar rotas automaticamente

# ARP global automático (resolve endereços automaticamente)
**.arp.typename = "GlobalArp"

# === CONFIGURAÇÕES CRÍTICAS PARA BROADCAST FUNCIONAR ===
# (Correção que resolveu o problema de zero transmissões)
**.ipv4.ip.limitedBroadcast = true              # CRÍTICO: habilitar broadcast limitado
**.ipv4.ip.directBroadcastInterfaces = "wlan0"  # Permitir broadcast direto na wlan0
**.ipv4.forwarding = false                      # Sem forwarding IP
**.ipv4.multicastForwarding = false             # Sem multicast forwarding

# Interface wireless configuração
**.wlan[*].mac.address = "auto"           # Endereço MAC automático
**.ipv4.routingTable.routerId = "auto"    # Router ID automático

# Configuração específica para ad-hoc (sem protocolos de roteamento)
**.hasAodv = false
**.hasGpsr = false

# === VISUALIZAÇÃO ===
**.visualizer.mobilityVisualizer.displayMobility = true
**.visualizer.mobilityVisualizer.displayPositions = true
**.visualizer.mobilityVisualizer.displayVelocities = true

# Visualização de radio com raios corretos por tipo de nó
**.visualizer.radioVisualizer.displayRadios = true
**.visualizer.radioVisualizer.displayRadioMode = true
**.visualizer.radioVisualizer.displayTransmissions = true
**.visualizer.radioVisualizer.displayCommunicationRange = true
**.visualizer.radioVisualizer.displayInterferenceRange = false

# Configurar raios de visualização específicos
**.gcs.visualizer.radioVisualizer.transmissionRange = 300m
**.uav[*].visualizer.radioVisualizer.transmissionRange = 200m

# Cores e filtros para melhor visualização
**.visualizer.mobilityVisualizer.nodeFilter = "**"
**.visualizer.radioVisualizer.nodeFilter = "**"
**.visualizer.radioVisualizer.packetFilter = "*"

# === LOG E DEBUG ===
cmdenv-express-mode = true
cmdenv-autoflush = true
cmdenv-status-frequency = 30s

# Logs focados nas camadas críticas para identificar onde param os pacotes
**.app[0].cmdenv-log-level = info
**.udp.cmdenv-log-level = info        # Ver fluxo UDP
**.ipv4.routingTable.cmdenv-log-level = info  # Ver tabela de rotas
**.ipv4.ip.cmdenv-log-level = info    # Ver decisões de roteamento IP
**.configurator.cmdenv-log-level = info # Ver configuração de rede
**.arp.cmdenv-log-level = info        # Ver resolução de endereços
**.wlan[*].mac.cmdenv-log-level = info  # Ver se chegam à camada MAC
**.wlan[*].radio.cmdenv-log-level = info # Ver transmissões wireless
**.radioMedium.cmdenv-log-level = info # Ver eventos do meio físico

debug-on-errors = true

# =============================================================================
# CONFIGURAÇÕES DE CENÁRIOS
# =============================================================================

[Config Default]
description = "FANET completo com 5 UAVs - cenário principal de demonstração"
# Mobilidade reduzida para manter topologia estratégica
**.uav[*].mobility.minSpeed = 5mps
**.uav[*].mobility.maxSpeed = 10mps
**.uav[*].mobility.updateInterval = 1s

[Config Debug]
description = "Teste de conectividade com 1 UAV próximo à GCS para debug"
**.numUAVs = 1  
sim-time-limit = 60s

# Posições muito próximas para garantir conectividade
**.uav[0].mobility.initialX = 1050m  
**.uav[0].mobility.initialY = 1050m  
**.uav[0].mobility.initialZ = 100m
**.uav[0].mobility.minSpeed = 0mps   # Estacionário para debug
**.uav[0].mobility.maxSpeed = 0mps

# Logs detalhados para debug
**.app[0].cmdenv-log-level = info
**.ipv4.**.cmdenv-log-level = info
**.wlan[*].**.cmdenv-log-level = info

[Config TestBasic]
description = "Teste simples de funcionamento básico"
**.numUAVs = 1
sim-time-limit = 30s

# Posição próxima para teste rápido
**.uav[0].mobility.initialX = 1050m
**.uav[0].mobility.initialY = 1050m
**.uav[0].mobility.initialZ = 100m
**.uav[0].mobility.minSpeed = 0mps
**.uav[0].mobility.maxSpeed = 0mps

[Config Quiet]
extends = Default
description = "Simulação silenciosa - apenas logs essenciais"
**.**.logLevel = "ERROR"  
**.app[0].logLevel = "WARN"
cmdenv-express-mode = true
**.scalar-recording = false
**.vector-recording = false

[Config SmallNetwork]
description = "Rede pequena com 3 UAVs para análise mais simples"
**.numUAVs = 3

[Config LargeNetwork] 
description = "Rede grande com 10 UAVs para teste de escalabilidade"
**.numUAVs = 10

[Config HighMobility]
description = "UAVs com alta mobilidade para teste de topologia dinâmica"
**.uav[*].mobility.minSpeed = 25mps
**.uav[*].mobility.maxSpeed = 35mps

[Config LowRange]
description = "Teste com alcance reduzido para forçar mais relay"
**.uav[*].app[0].maxTransmissionRange = 150m
**.gcs.app[0].maxTransmissionRange = 200m
**.uav[*].wlan[*].radio.transmitter.power = 5mW
