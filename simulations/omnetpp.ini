# =============================================================================
# FANET (Flying Ad-hoc Network) Simulation Configuration
# 
# Simulação de rede ad-hoc de veículos aéreos não tripulados (UAVs)
# com Estação de Controle Terrestre (GCS)
# =============================================================================

[General]
network = FANET
sim-time-limit = 300s  # 5 minutos de simulação
seed-set = ${runnumber}

# === CONFIGURAÇÕES DE LOG ===
# Configurações globais do cmdenv
cmdenv-express-mode = true
cmdenv-autoflush = true
cmdenv-log-prefix = "[%l] %C: "

# Reduzir verbosidade dos logs do sistema
**.scalar-recording = false
**.vector-recording = false

# Filtros de log para mostrar apenas informações relevantes  
**.**.logLevel = "WARN"    # Apenas warnings e erros por padrão
**.app[0].logLevel = "INFO"   # Manter logs da aplicação FANET

# === CONFIGURAÇÃO DA REDE ===
**.numUAVs = 5  # 5 UAVs + 1 GCS

# === MOBILIDADE ===
# UAVs com mobilidade arbitrária (reduzida para manter posições estratégicas)
**.uav[*].mobility.typename = "ArbitraryMobility"
**.uav[*].mobility.minSpeed = 5mps    # Velocidade reduzida para manter topologia
**.uav[*].mobility.maxSpeed = 10mps   # Velocidade reduzida para manter topologia
**.uav[*].mobility.minAltitude = 80m
**.uav[*].mobility.maxAltitude = 120m
**.uav[*].mobility.constraintAreaMinX = 200m
**.uav[*].mobility.constraintAreaMinY = 200m
**.uav[*].mobility.constraintAreaMaxX = 1800m
**.uav[*].mobility.constraintAreaMaxY = 1800m
**.uav[*].mobility.updateInterval = 1s  # Movimento mais lento

# Posições iniciais calculadas para demonstrar relay natural
# GCS no centro (1000, 1000) com alcance de 500m
# Distâncias calculadas para garantir conectividade em cadeia

# Posições iniciais estratégicas para forçar relay multi-hop
# GCS no centro (1000, 1000) com alcance de 300m
# UAVs com alcance de 200m
# Topologia em cadeia: UAV[0,1,2] → GCS | UAV[3] → UAV[1] → GCS | UAV[4] → UAV[3] → UAV[1] → GCS

# UAVs 0-2: Dentro do alcance direto do GCS (< 300m)
**.uav[0].mobility.initialX = 850m   # Distância do GCS: ~212m
**.uav[0].mobility.initialY = 850m
**.uav[0].mobility.initialZ = 100m

**.uav[1].mobility.initialX = 1100m  # Distância do GCS: ~141m (ponte para relay)
**.uav[1].mobility.initialY = 1100m
**.uav[1].mobility.initialZ = 100m

**.uav[2].mobility.initialX = 800m   # Distância do GCS: ~200m
**.uav[2].mobility.initialY = 1000m
**.uav[2].mobility.initialZ = 100m

# UAV[3]: Primeiro relay - fora do GCS mas conectado ao UAV[1] 
**.uav[3].mobility.initialX = 1240m  # Distância do GCS: ~339m (fora de 300m)
**.uav[3].mobility.initialY = 1240m  # Distância do UAV[1]: ~198m (dentro de 200m) ✓
**.uav[3].mobility.initialZ = 100m

# UAV[4]: Segundo relay - conectado apenas ao UAV[3]
**.uav[4].mobility.initialX = 1380m  # Distância do GCS: ~537m (muito fora)
**.uav[4].mobility.initialY = 1380m  # Distância do UAV[3]: ~198m (dentro de 200m) ✓
**.uav[4].mobility.initialZ = 100m

# GCS estacionária no centro
**.gcs.mobility.typename = "StationaryMobility"
**.gcs.mobility.initialX = 1000m
**.gcs.mobility.initialY = 1000m
**.gcs.mobility.initialZ = 10m

# === APLICAÇÃO FANET ===
**.app[0].typename = "FANETApp"
**.app[0].localPort = 1000
**.app[0].destPort = 1000
**.app[0].neighborTimeout = 30s
**.app[0].startTime = 1s

# Configurações específicas por tipo de nó
**.uav[*].app[0].isGCS = false
**.uav[*].app[0].maxTransmissionRange = 200m  # Mais conservador que a física (250m)

**.gcs.app[0].isGCS = true
**.gcs.app[0].maxTransmissionRange = 300m  # Mais conservador que a física (400m)

# === INTERFACES WIRELESS ===
# Configuração explícita para AdhocHost - garantir operação correta

# Configurações MAC para broadcast otimizado
**.wlan[*].mac.dcf.channelAccess.pendingQueue.typename = "DropTailQueue"
**.wlan[*].mac.dcf.channelAccess.pendingQueue.frameCapacity = 10

# Configurações explícitas para modo ad-hoc
**.wlan[*].mgmt.ssid = "FANET"
**.wlan[*].mgmt.typename = "Ieee80211MgmtAdhoc"
**.wlan[*].mac.address = "auto"

# FORÇAR interface ATIVA desde o início
**.wlan[*].radio.radioMedium = "radioMedium"  # Conectar ao meio físico
**.interfaceTable.displayAddresses = true

# Forçar resolução ARP automática para broadcasts
**.arp.typename = "GlobalArp"  # Resolver endereços automaticamente

# === POTÊNCIA DE TRANSMISSÃO ===
# Configurações muito restritivas para forçar alcances corretos
**.uav[*].wlan[*].radio.transmitter.power = 15mW     # ~250m alcance máximo
**.gcs.wlan[*].radio.transmitter.power = 80mW       # ~400m alcance máximo
**.wlan[*].radio.centerFrequency = 2.4GHz

# Configurações de antena
**.wlan[*].radio.antenna.typename = "IsotropicAntenna"

# === MEIO FÍSICO ===
**.radioMedium.typename = "Ieee80211ScalarRadioMedium"
**.radioMedium.mediumLimitCache.carrierFrequency = 2.4GHz
**.radioMedium.backgroundNoise.power = -110dBm  # Ruído de fundo baixo e realístico

# Configurações específicas do radioMedium para INET 4.5.4
**.radioMedium.pathLoss.typename = "FreeSpacePathLoss"
**.radioMedium.pathLoss.alpha = 2.0  # Expoente de perda de caminho
**.radioMedium.pathLoss.systemLoss = 0dB  # Sem perdas adicionais do sistema
**.radioMedium.obstacleLoss.typename = ""
**.radioMedium.analogModel.typename = "ScalarAnalogModel"

# Adicionando filtro de proximidade mais rigoroso
**.radioMedium.neighborCache.maxCommunicationRange = 300m  # Mais restritivo
**.radioMedium.communicationCache.maxCommunicationRange = 300m

# Forçar limite de comunicação baseado na distância - muito restritivo
**.radioMedium.rangeFilter.maxCommunicationRange = 300m  # Limite absoluto baixo
**.radioMedium.rangeFilter.maxInterferenceRange = 350m

# Configurações de recepção balanceadas - permitir comunicação mas com controle na aplicação
**.uav[*].wlan[*].radio.receiver.energyDetection = -95dBm  # Detectar sinais fracos
**.uav[*].wlan[*].radio.receiver.sensitivity = -95dBm      # Receber sinais adequados
**.gcs.wlan[*].radio.receiver.energyDetection = -100dBm    # GCS mais sensível   
**.gcs.wlan[*].radio.receiver.sensitivity = -100dBm        # GCS pode receber sinais mais fracos

# === CONFIGURAÇÃO IP ===
# Configuração mais explícita para AdhocHost no INET 4.5.4
**.configurator.config = xmldoc("network-config.xml")

# Configurações críticas para AdhocHost funcionar corretamente
**.configurator.addDefaultRoutes = false  # Não adicionar rotas padrão automáticas
**.configurator.addStaticRoutes = true    # MUDANÇA: Adicionar rotas estáticas
**.configurator.addSubnetRoutes = true    # Adicionar rotas de subnet
**.configurator.optimizeRoutes = false    # Não otimizar rotas

# ARP automático (componente pronto do INET)
**.arp.typename = "GlobalArp"

# Configurações IP específicas para ad-hoc
**.ipv4.ip.limitedBroadcast = true   # MUDANÇA CRÍTICA: habilitar broadcast limitado
**.ipv4.forwarding = false           # Sem forwarding
**.ipv4.multicastForwarding = false  # Sem multicast forwarding

# CONFIGURAÇÕES CRÍTICAS PARA BROADCAST FUNCIONAR
**.ipv4.ip.directBroadcastInterfaces = "wlan0"  # Permitir broadcast direto na wlan0
**.wlan[*].mac.address = "auto"  # Endereço MAC automático

# Forçar interface WLAN como interface de broadcast
**.ipv4.routingTable.routerId = "auto"

# Configuração específica para ad-hoc
**.hasAodv = false
**.hasGpsr = false

# FORÇAR interface wireless como padrão para broadcast
**.interfaceTable.interfaces = "wlan0"
**.wlan[*].interfaceEntry.broadcast = true

# === VISUALIZAÇÃO ===
**.visualizer.mobilityVisualizer.displayMobility = true
**.visualizer.mobilityVisualizer.displayPositions = true
**.visualizer.mobilityVisualizer.displayVelocities = true

# Visualização de radio com raios corretos por tipo de nó
**.visualizer.radioVisualizer.displayRadios = true
**.visualizer.radioVisualizer.displayRadioMode = true
**.visualizer.radioVisualizer.displayTransmissions = true
**.visualizer.radioVisualizer.displayCommunicationRange = true
**.visualizer.radioVisualizer.displayInterferenceRange = false

# Configurar raios de visualização específicos
**.gcs.visualizer.radioVisualizer.transmissionRange = 300m
**.uav[*].visualizer.radioVisualizer.transmissionRange = 200m

# Cores e filtros para melhor visualização
**.visualizer.mobilityVisualizer.nodeFilter = "**"
**.visualizer.radioVisualizer.nodeFilter = "**"
**.visualizer.radioVisualizer.packetFilter = "*"

# === LOG E DEBUG ===
cmdenv-express-mode = true
cmdenv-autoflush = true
cmdenv-status-frequency = 30s

# Logs focados nas camadas críticas para identificar onde param os pacotes
**.app[0].cmdenv-log-level = info
**.udp.cmdenv-log-level = info        # Ver fluxo UDP
**.ipv4.routingTable.cmdenv-log-level = info  # Ver tabela de rotas
**.ipv4.ip.cmdenv-log-level = info    # Ver decisões de roteamento IP
**.configurator.cmdenv-log-level = info # Ver configuração de rede
**.arp.cmdenv-log-level = info        # Ver resolução de endereços
**.wlan[*].mac.cmdenv-log-level = info  # Ver se chegam à camada MAC
**.wlan[*].radio.cmdenv-log-level = info # Ver transmissões wireless
**.radioMedium.cmdenv-log-level = info # Ver eventos do meio físico

debug-on-errors = true

# =============================================================================
# CONFIGURAÇÕES DE CENÁRIOS
# =============================================================================

[Config Default]
description = "FANET básico com 5 UAVs e 1 GCS - topologia fixa para teste"
# Mobilidade quase estacionária para manter topologia de relay
**.uav[*].mobility.minSpeed = 1mps
**.uav[*].mobility.maxSpeed = 2mps
**.uav[*].mobility.updateInterval = 5s

[Config Debug]
description = "Teste de debug com apenas 2 nós próximos para verificar conectividade básica"
**.numUAVs = 1  # Apenas 1 UAV + GCS para teste simples
sim-time-limit = 60s  # Simulação mais curta para debug

# Posições muito próximas para garantir conectividade
**.uav[0].mobility.initialX = 1050m  # Apenas 50m do GCS
**.uav[0].mobility.initialY = 1050m  # Distância: ~71m (muito dentro do alcance)
**.uav[0].mobility.initialZ = 100m
**.uav[0].mobility.minSpeed = 0mps   # Estacionário para debug
**.uav[0].mobility.maxSpeed = 0mps

# Logs ainda mais detalhados
**.wlan[*].**.cmdenv-log-level = trace
**.ipv4.**.cmdenv-log-level = trace
**.udp.**.cmdenv-log-level = trace

[Config TestUDP]
description = "Teste básico UDP entre dois AdhocHosts"
network = TestUDPNetwork
sim-time-limit = 20s

# Configuração IP simples
**.configurator.config = xml("<config><interface hosts='**' address='10.0.0.x' netmask='255.255.255.0'/></config>")

# Apps simples
**.sender.numApps = 1
**.sender.app[0].typename = "UdpBasicApp"
**.sender.app[0].destAddresses = "10.0.0.2"
**.sender.app[0].destPort = 1000
**.sender.app[0].messageLength = 64B
**.sender.app[0].sendInterval = 1s
**.sender.app[0].startTime = 2s

**.receiver.numApps = 1  
**.receiver.app[0].typename = "UdpSink"
**.receiver.app[0].localPort = 1000

# Configuração wireless básica
**.wlan[*].mgmt.typename = "Ieee80211MgmtAdhoc"
**.wlan[*].mgmt.ssid = "TEST"
**.wlan[*].radio.transmitter.power = 20mW
**.radioMedium.typename = "Ieee80211ScalarRadioMedium"

# Logs
**.app[*].cmdenv-log-level = info
**.ipv4.**.cmdenv-log-level = info  
**.wlan[*].**.cmdenv-log-level = info
**.radioMedium.cmdenv-log-level = info
cmdenv-express-mode = false

[Config TestBasic]
description = "Teste básico de conectividade com configuração limpa"
**.numUAVs = 1
sim-time-limit = 30s

# Posições muito próximas (50m de distância)
**.uav[0].mobility.initialX = 1050m
**.uav[0].mobility.initialY = 1050m
**.uav[0].mobility.initialZ = 100m
**.uav[0].mobility.minSpeed = 0mps
**.uav[0].mobility.maxSpeed = 0mps

# Logs detalhados apenas nas camadas críticas
**.configurator.cmdenv-log-level = info
**.ipv4.routingTable.cmdenv-log-level = info
**.wlan[*].mac.cmdenv-log-level = info
**.radioMedium.cmdenv-log-level = info

[Config TestDirect]
description = "Teste diagnóstico com configuração IP manual e endereços específicos"
sim-time-limit = 30s
**.numUAVs = 1

# Forçar configuração IP manual muito específica
**.configurator.config = xmldoc("test-config.xml")

# Posições muito próximas (50m)
**.uav[0].mobility.initialX = 1050m
**.uav[0].mobility.initialY = 1050m
**.uav[0].mobility.initialZ = 100m
**.uav[0].mobility.minSpeed = 0mps
**.uav[0].mobility.maxSpeed = 0mps

# Usar PingApp com endereços específicos conhecidos
**.numApps = 1

# GCS pingando UAV com endereço conhecido
**.gcs.app[0].typename = "PingApp"
**.gcs.app[0].destAddr = "192.168.1.2"  # Endereço específico do UAV
**.gcs.app[0].startTime = 5s
**.gcs.app[0].sendInterval = 2s
**.gcs.app[0].packetSize = 56B

# UAV não pingando de volta para simplificar
**.uav[0].numApps = 0

# Logs críticos apenas na camada que está falhando
**.ipv4.routingTable.cmdenv-log-level = detail
**.ipv4.ip.cmdenv-log-level = detail
**.wlan[*].mac.cmdenv-log-level = detail  
**.wlan[*].radio.cmdenv-log-level = detail
**.radioMedium.cmdenv-log-level = detail
**.app[0].cmdenv-log-level = detail

# LOGS CRÍTICOS PARA DIAGNÓSTICO
**.interfaceTable.cmdenv-log-level = detail  # Ver interfaces disponíveis
**.configurator.cmdenv-log-level = detail    # Ver configuração de rede
**.arp.cmdenv-log-level = detail             # Ver resolução ARP

cmdenv-express-mode = false  # Ver eventos em detalhe

[Config TestPingOnly]
description = "Teste com PingApp padrão do INET para verificar stack de rede"
sim-time-limit = 30s
**.numUAVs = 1

# Posições próximas
**.uav[0].mobility.initialX = 1050m
**.uav[0].mobility.initialY = 1050m
**.uav[0].mobility.initialZ = 100m
**.uav[0].mobility.minSpeed = 0mps
**.uav[0].mobility.maxSpeed = 0mps

# Substituir aplicação FANET por PingApp
**.numApps = 1

# GCS pingando UAV
**.gcs.app[0].typename = "PingApp"
**.gcs.app[0].destAddr = "192.168.1.2"
**.gcs.app[0].startTime = 5s
**.gcs.app[0].sendInterval = 1s

# UAV como receptor
**.uav[0].app[0].typename = "PingApp"
**.uav[0].app[0].destAddr = "192.168.1.1" 
**.uav[0].app[0].startTime = 7s
**.uav[0].app[0].sendInterval = 2s

# Logs MUITO detalhados para identificar onde param os pacotes
cmdenv-express-mode = false  # Mostrar todos os detalhes
**.configurator.cmdenv-log-level = detail
**.ipv4.**.cmdenv-log-level = detail
**.wlan[*].**.cmdenv-log-level = detail
**.radioMedium.**.cmdenv-log-level = detail
**.arp.cmdenv-log-level = detail
**.app[0].cmdenv-log-level = detail

[Config Quiet]
extends = Default
description = "Simulação silenciosa - apenas logs essenciais"
**.**.logLevel = "ERROR"  
**.app[0].logLevel = "WARN"
cmdenv-express-mode = true
**.scalar-recording = false
**.vector-recording = false

[Config SmallNetwork]
description = "Rede pequena com 3 UAVs"
**.numUAVs = 3

[Config LargeNetwork] 
description = "Rede grande com 10 UAVs"
**.numUAVs = 10

[Config HighMobility]
description = "UAVs com alta mobilidade"
**.uav[*].mobility.minSpeed = 25mps
**.uav[*].mobility.maxSpeed = 35mps

[Config LowRange]
description = "Teste com alcance reduzido"
**.uav[*].app[0].maxTransmissionRange = 200m
**.uav[*].wlan[*].radio.transmitter.power = 10mW
